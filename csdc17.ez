/*_____________________________________________________________

Template for an EASEA evolutionary algorithm for easea v1.0.3
_______________________________________________________________*/

\User declarations : // This section is copied on top of the output file
#include <string>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>

#define UNDEF "UNDEFINED"
#define PATH_TRACKS "tracks.csv"

using namespace std;

enum PAPER_TYPE_ENUM {
	FULL_PAPER,
	POSTER,
	SHORT_PAPER
};

class Paper {
   public:
	int paperId;
	int trackId;
	int sessionId;
	int primaryAuthorId;
	int decision;
	int duration; // minutes
	
	string startingTime;
	string rank;
	string paperType;
	string paperTitle;
	string sessionTitle;
	string trackTitle;
	
	string utc;
	string primaryAuthor;
	string primaryAuthorCountry;
	string constraintDay1;
	string constraintDay2;
	string constraintDay3;
	
	string authors;
	
	
	void displayPaper(){
		cout << "----" << endl;
		cout << "Paper ID : " << paperId << endl;
		cout << "Paper Title : " << paperTitle << endl;
		cout << "E-Track ID : " << trackId << endl;
		cout << "E-Track Title : " << trackTitle << endl;
		cout << "E-Session ID : " << sessionId << endl;
		cout << "E-Session Title : " << sessionTitle << endl;
		cout << "Primary Author ID : " << primaryAuthorId << endl;
		cout << "Primary Author : " << primaryAuthor << endl;
		cout << "Primary Author's Country : " << primaryAuthorCountry << endl;
		cout << "Authors : " << authors << endl;
		cout << "Paper's type : " << paperType << endl;
		cout << "Duration : " << duration << endl;
		cout << "Decision : " << decision << endl;
		cout << "Starting time : " << startingTime << endl;
		cout << "Rank : " << rank << endl;
		cout << "UTC time : " << utc << endl;
		cout << "Constraint Day 1 : " << constraintDay1 << endl;
		cout << "Constraint Day 2 : " << constraintDay2 << endl;
		cout << "Constraint Day 3 : " << constraintDay3 << endl;
	};
	
	void computeDuration()
	{
		if(strcmp(paperType.c_str(), "Poster") == 0)
			duration = 5;
		else if(strcmp(paperType.c_str(), "Short paper") == 0)
			duration = 15;
		else if(strcmp(paperType.c_str(), "Plenary talk") == 0)
			duration = 60;
		else if(strcmp(paperType.c_str(), "Advanced Introduction invited talk") == 0)
			duration = 30;

			
	}
	
};

ifstream fPaper;

vector<Paper> papers;
\end

\User functions:
// Paper format :
// Paper ID|Paper Title|E-Track ID|E-Track Title|E-Session ID|E-Session Title|Primary Author ID|Primary Author|Primary Author's Country|Authors|Paper's type|Decision|Starting Time|Rank|UTC time|Times Constraints - Day 1|Times Constraints - Day 2|Times Constraints - Day 3
void readTracksFile(){
	
	cout << "[INFOS] Papers loading..." << endl;
	fPaper.open(PATH_TRACKS, ios::in);
	string line;
	int nb_records = 0;
	if (fPaper.is_open()) {
		Paper p;
		while ( getline (fPaper,line) ) {
			line.erase(line.length()-1,line.length()-1);
			char * cstr = new char [line.length()+1];
			strcpy (cstr, line.c_str());
			char *szKeywords, *szAbstKeywords;
			char * s;
			if(nb_records > 0)
			{
				s = strtok (cstr,"|");
				p.paperId = atoi(s) > 0 ? atoi(s):-1;
				s = strtok (NULL, "|"); p.paperTitle = s ? s : UNDEF;
				s = strtok (NULL, "|"); p.trackId = atoi(s);
				s = strtok (NULL, "|"); p.trackTitle = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.sessionId = atoi(s) > 0 ? atoi(s):-1;
				s = strtok (NULL, "|"); p.sessionTitle = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.primaryAuthorId = atoi(s) > 0 ? atoi(s):-1;
				s = strtok (NULL, "|"); p.primaryAuthor = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.primaryAuthorCountry = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.authors = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.paperType = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.decision = s ? atoi(s) : 0;
				s = strtok (NULL, "|"); p.startingTime = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.rank = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.utc = s ? s :UNDEF;				
				s = strtok (NULL, "|"); p.constraintDay1 = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.constraintDay2 = s ? s :UNDEF;
				s = strtok (NULL, "|"); p.constraintDay3 = s ? s : UNDEF;	
						
				p.computeDuration();
				papers.push_back(p);		

			}
			nb_records++;
		}
	}
	fPaper.close();
	cout << "[INFOS] (" << papers.size() << ") papers loaded!" << endl;
} 

void getPapersForTrackId(int id)
{
	for (int i=0;i<papers.size();i++){
		if(papers[i].trackId == id)
			papers[i].displayPaper();
	}
}

\end

\User CUDA:
//Transfert some variables to GPU here (cudaMalloc, MemCpy)
\end

\User classes :
GenomeClass { 
  // need to declare the genome here
  int i;
  int trackId;
  int sessionId;
  int position;
  string startingTime;
  
}
\end

\Before everything else function:
//cout<<"Before everything else function called "<<endl;
\end

\After everything else function:
readTracksFile();
getPapersForTrackId(5);
\end

\At the beginning of each generation function:
//cout << "At the beginning of each generation function called" << endl;
\end

\At the end of each generation function:
//cout << "At the end of each generation function called" << endl;
\end

\At each generation before reduce function:
//cout << "At each generation before replacement function called" << endl;
\end

\GenomeClass::display:
\end

\GenomeClass::initialiser : // "initializer" is also accepted
  // the genome to initialise is known as "Genome"
\end

\GenomeClass::crossover : 
  // must create "child" out of "parent1" and "parent2"
\end

\GenomeClass::mutator : // Must return the number of mutations
  // must mutate "Genome"
  return 0;
\end

\GenomeClass::evaluator : // Returns the score as a real value
  // uses Genome to evaluate the quality of the individual
  return 0.0;
\end

\User Makefile options: 
\end

\Default run parameters :        // Please let the parameters appear in this order
  Number of generations : 100    // NB_GEN
  Time limit: 0 			           // In seconds, 0 to deactivate
  Population size : 1024			   //POP_SIZE
  Offspring size : 1024 // or a xx%
  Mutation probability : 1       // MUT_PROB
  Crossover probability : 1      // XOVER_PROB
  Evaluator goal : maximize      // maximise
  Selection operator: Tournament 2.0
  Surviving parents: 100%        // Percentage or absolute  
  Surviving offspring: 100%      // Percentage or absolute  
  Reduce parents operator: Tournament 2
  Reduce offspring operator: Tournament 2
  Final reduce operator: Tournament 2

  Elitism: Strong			           // Weak or Strong
  Elite: 1
  Print stats: true				       // Default: 1
  Generate csv stats file:false			
  Generate gnuplot script:false
  Generate R script:false
  Plot stats:true				         // Default: 0

  Remote island model: false
  IP file: ip.txt 			         // List of IP:PORT of islands to send individuals to
  Migration probability: 0.33    // Probability of sending an individual per generation
  Server port : 2929

  Save population: false
  Start from file:false
\end
